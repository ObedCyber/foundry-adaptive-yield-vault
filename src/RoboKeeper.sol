// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {AutomationCompatibleInterface} from "@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol";
import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {IStrategyManager} from "./IStrategyManager.sol";

contract RoboKeeper is AutomationCompatibleInterface, Ownable {

    error StrategyManager__RebalanceOnCooldown();

    uint256 public yieldDeviation;
    uint256 public rebalanceCooldown;
    uint256 public lastRebalanceTimestamp; // timestamp of the last rebalance

    IStrategyManager public strategyManager;

    constructor(
        uint256 _yieldDeviation, 
        address _strategyManager, 
        uint256 _rebalanceCooldown)Ownable(msg.sender){
        yieldDeviation = _yieldDeviation;
        strategyManager = IStrategyManager(_strategyManager);
        rebalanceCooldown = _rebalanceCooldown;
    }

    /// @dev Checks if the rebalance is on cooldown.
    modifier rebalanceIsOnCooldown(){
            if(rebalanceCooldown > (lastRebalanceTimestamp - block.timestamp))  revert StrategyManager__RebalanceOnCooldown();
            _;
    }


    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (bool upkeepNeeded, bytes memory /* performData */)
    {
       // get the best strategy
       uint256 bestIndex = strategyManager.getBestAPYStrategy();

       // get the current strategy
       uint256 currentIndex = strategyManager.getCurrentStrategyIndex();

       // if best strategy is current, upkeepNeeded is false
       if(bestIndex == currentIndex){
        upkeepNeeded = false;
        return (upkeepNeeded,"");
       }

        uint256 currentAPY = strategyManager.getStrategyAPY(currentIndex);
        uint256 bestAPY = strategyManager.getStrategyAPY(bestIndex);

        if(bestAPY > currentAPY && (bestAPY - currentAPY) > yieldDeviation){
            upkeepNeeded = true;
            return (upkeepNeeded,"");
        }
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        // check if rebalance cooldown has reached
       if(rebalanceCooldown < (lastRebalanceTimestamp - block.timestamp)) {
            strategyManager.Rebalance();
       }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    // @dev Updates the rebalance cooldown period.
    // RebalanceCooldown period can only be updated when rebalance is on cooldown
    // so that values won't be changes while rebalancing is in progress
    function updateRebalanceCooldown(uint256 newRebalanceCooldown) public onlyOwner rebalanceIsOnCooldown {
        rebalanceCooldown = newRebalanceCooldown;
    }
}